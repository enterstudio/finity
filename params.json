{"name":"Finity","tagline":"Slim and readable state machine for Ruby","body":"# Finity\r\n\r\n**Finity** tries to be an extremly lightweight state machine implementation\r\nwith an easily readable syntax. At the time of this writing, **Finity** is\r\ncomprised of only ~160 lines of code. It is inspired by [transitions][], a\r\ngreat state machine implementation tightly integrated with ActiveRecord by\r\nJakub Kuźma and Timo Rößner.\r\n\r\nThe aim of **Finity** is to provide a state machine implementation which is as\r\nslim and fast as possible while maintaining a beautiful and readable syntax.\r\nHowever, if you need ActiveModel/ActiveRecord integration, [transitions][] may\r\nbe your weapon of choice.\r\n\r\n## Installation\r\n\r\nIf you use Rails, include this into your Gemfile and run `bundle install` via\r\ncommand line:\r\n\r\n``` ruby\r\ngem 'finity'\r\n```\r\n\r\nOtherwise you can install **Finity** with `gem` via command\r\nline:\r\n\r\n```\r\ngem install finity\r\n```\r\n\r\n## Example\r\n\r\n**Finity** can transform any class into a state machine. For example, consider\r\na state machine modelling an *elevator* in a building with 3 floors: `ground`,\r\n`first` and `second`. The *elevator* can perform the following actions:\r\n\r\n* On floors `ground` and `first`, it can go `up` to the floor above.\r\n* On floors `first` and `second`, it can go `down` to the floor below.\r\n\r\n*Leaving* (*entering*) a floor, the doors need to `close` (`open`). Also, when\r\nentering a floor or pressing `down` (`up`) on the `ground` (`second`) floor, a\r\nbell should `ring`. The following class models the *elevator*:\r\n\r\n``` ruby\r\nclass Elevator\r\n  include Finity\r\n\r\n  finity :init => :ground do\r\n\r\n    state :ground,\r\n      :enter => :open,\r\n      :cycle => :ring,\r\n      :leave => :close\r\n\r\n    state :first,\r\n      :enter => :open,\r\n      :leave => :close\r\n\r\n    state :second,\r\n      :enter => :open,\r\n      :cycle => :ring,\r\n      :leave => :close\r\n\r\n    event :up do\r\n      transitions :from => [:ground], :to => :first\r\n      transitions :from => [:first, :second], :to => :second\r\n    end\r\n\r\n    event :down do\r\n      transitions :from => [:ground, :first], :to => :ground\r\n      transitions :from => [:second], :to => :first\r\n    end\r\n  end\r\n\r\n  def up\r\n    event! :up\r\n  end\r\n  \r\n  def down\r\n    event! :down\r\n  end\r\n\r\n  private\r\n\r\n  def open\r\n    ring and puts \"Doors opening on the #{@current} floor.\"\r\n  end\r\n\r\n  def ring\r\n    puts \"Ring!\"\r\n  end\r\n\r\n  def close\r\n    puts \"Doors closing...\"\r\n  end\r\nend\r\n```\r\n\r\nWhile the different floors are modelled as *states*, the actions `up` and\r\n`down` are modelled as *events*. The *elevator* is initialized on the `ground`\r\nfloor, which in this case is redundant, since, by default, **Finity** treats\r\nthe first state as the initial state. The instance variable `@current` holds\r\nthe current floor/state. The methods which are invoked upon entering, leaving\r\nor cycling (staying in a state) are declared private, as they should not be\r\naccessible from the outside. Only `up` and `down` are public.\r\n\r\nWe can now create an instance of the *elevator* and play with it:\r\n\r\n``` ruby\r\nelevator = Elevator.new\r\nelevator.down # => Ring!\r\nelevator.up   # => Doors closing...\r\n              # => Ring!\r\n              # => Doors opening on the first floor.\r\nelevator.up   # => Doors closing...\r\n              # => Ring!\r\n              # => Doors opening on the second floor.\r\nelevator.up   # => Ring!\r\nelevator.down # => Doors closing.\r\n              # => Ring!\r\n              # => Doors opening on the first floor.\r\n```\r\n\r\nWhile this example is very basic, it clearly shows the power of finite state\r\nmachines to model complex systems with a finite set of states and events\r\ntriggering transitions between them.\r\n\r\n## States, Events and Transitions\r\n\r\n### States\r\n\r\nA state is uniquely identified by its name and *can* define functions to be\r\nexecuted upon entering, leaving and cycling (staying inside). These functions\r\ncan be referenced as *Symbols*, *Strings*, *Procs* or *Lambdas*:\r\n\r\n``` ruby\r\nstate :ground,\r\n  :enter => :open,                           # Symbols must reference (private) methods\r\n  :cycle => proc { ring },                   # Procs are evaluated in the context of the instance\r\n  :leave => -> elevator { elevator.close }   # Lambdas are provided with the instance as an argument\r\n```\r\n\r\nIf there are several states with the same set of transition functions, they can\r\nbe defined in a single run. Considering our example, the `ground` and the\r\n`second` floor bear the same set of actions, so we can combine them:\r\n\r\n``` ruby\r\nstate [:ground, :second],\r\n  :enter => :open,\r\n  :cycle => :ring,\r\n  :leave => :close\r\n```\r\n\r\n### Events and Transitions\r\n\r\nEvents are like states identified by their name and may define an arbitrary\r\nnumber of transitions between different states. The transitions are evaluated\r\nin the order in which they are defined. A transition is executed, if it is found\r\nto be valid, which means that it contains the current state in `from` and the\r\n`if`-guard, if defined, returns `true`. If no valid transition is found for a\r\ngiven event, **Finity** will raise an error. Starting with our example, the\r\nminimal information needed for the `up`-event is:\r\n\r\n``` ruby\r\nevent :up do\r\n  transitions :from => [:ground], :to => :first\r\n  transitions :from => [:first, :second], :to => :second\r\nend\r\n```\r\n\r\nLike for states, multiple events can be defined in a single run with the same\r\nset of transitions:\r\n\r\n``` ruby\r\nevent [:up, :down] do\r\n  ...\r\nend\r\n```\r\n\r\nIn case of an event, we sometimes want to take different actions from the same\r\nstate, so we need to specify *guards*. If a transition specifies a guard, it is\r\nonly considered valid if the guard returns `true`. For example, if we want to\r\ndeactivate the buttons when the elevator is `stuck`, we do the following:\r\n\r\n``` ruby\r\nevent :up do\r\n  transitions :from => [:ground], :to => :first,\r\n    :if => :not_stuck?\r\n  transitions :from => [:first, :second], :to => :second,\r\n    :if => :not_stuck?\r\n  transitions :from => [:ground, :first, :second, :stuck], :to => :stuck\r\nend\r\n```\r\n\r\nThis implies, that we defined a new state called `stuck` and a method to\r\ndetermine whether the elevator is stuck at the moment. Unless `not_stuck?`\r\nreturns `true`, the elevator will keep working as in our original example.\r\nOtherwise, only the last transition is valid and the elevator will enter\r\nthe `stuck` state from any other state.\r\n\r\nAdditionally, we can define functions to be executed for specific transitions\r\nonly. This can be achieved with `do`:\r\n\r\n``` ruby\r\nevent :up do\r\n  transitions :from => [:ground], :to => :first,\r\n    :if => :not_stuck?\r\n  transitions :from => [:first, :second], :to => :second,\r\n    :if => :not_stuck?\r\n  transitions :from => [:ground, :first, :second, :stuck], :to => :stuck,\r\n    :do => proc { puts \"The elevator is stuck\" }\r\nend\r\n```\r\n\r\nNow, if the elevator is stuck, a message is displayed everytime a button is\r\npushed. Like for states, all functions can be defined as *Symbols*, *Strings*,\r\n*Procs* or *Lambdas*.\r\n\r\n### Definitions\r\n\r\n**Finity** defines two methods on the including instance:\r\n\r\n* `state? name`: Returns `true` if the state machine is in state `name`.\r\n* `event! name`: Triggers event `name`.\r\n\r\nThose methods can also be accessed from the outside. The current state is held\r\nwithin the instance variable `@current`, contained in the including instance.\r\n\r\n## License\r\n\r\nCopyright (c) 2012 Martin Donath\r\n\r\nPermission is hereby granted, free of charge, to any person\r\nobtaining a copy of this software and associated documentation files\r\n(the \"Software\"), to deal in the Software without restriction,\r\nincluding without limitation the rights to use, copy, modify, merge,\r\npublish, distribute, sublicense, and/or sell copies of the Software,\r\nand to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\r\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\n[transitions]: https://github.com/troessner/transitions","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}